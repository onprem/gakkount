// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/prmsrswt/edu-accounts/ent/course"
	"github.com/prmsrswt/edu-accounts/ent/department"
	"github.com/prmsrswt/edu-accounts/ent/user"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCourse     = "Course"
	TypeDepartment = "Department"
	TypeUser       = "User"
)

// CourseMutation represents an operation that mutate the Courses
// nodes in the graph.
type CourseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	code          *string
	semesters     *int
	addsemesters  *int
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Course, error)
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows to manage the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for $n.Name.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the id field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CourseMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *CourseMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *CourseMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *CourseMutation) ResetCode() {
	m.code = nil
}

// SetSemesters sets the semesters field.
func (m *CourseMutation) SetSemesters(i int) {
	m.semesters = &i
	m.addsemesters = nil
}

// Semesters returns the semesters value in the mutation.
func (m *CourseMutation) Semesters() (r int, exists bool) {
	v := m.semesters
	if v == nil {
		return
	}
	return *v, true
}

// OldSemesters returns the old semesters value of the Course.
// If the Course object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CourseMutation) OldSemesters(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemesters is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemesters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemesters: %w", err)
	}
	return oldValue.Semesters, nil
}

// AddSemesters adds i to semesters.
func (m *CourseMutation) AddSemesters(i int) {
	if m.addsemesters != nil {
		*m.addsemesters += i
	} else {
		m.addsemesters = &i
	}
}

// AddedSemesters returns the value that was added to the semesters field in this mutation.
func (m *CourseMutation) AddedSemesters() (r int, exists bool) {
	v := m.addsemesters
	if v == nil {
		return
	}
	return *v, true
}

// ResetSemesters reset all changes of the "semesters" field.
func (m *CourseMutation) ResetSemesters() {
	m.semesters = nil
	m.addsemesters = nil
}

// AddUserIDs adds the users edge to User by ids.
func (m *CourseMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *CourseMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *CourseMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *CourseMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *CourseMutation) ResetUsers() {
	m.users = nil
	m.removedusers = nil
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, course.FieldName)
	}
	if m.code != nil {
		fields = append(fields, course.FieldCode)
	}
	if m.semesters != nil {
		fields = append(fields, course.FieldSemesters)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldName:
		return m.Name()
	case course.FieldCode:
		return m.Code()
	case course.FieldSemesters:
		return m.Semesters()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldName:
		return m.OldName(ctx)
	case course.FieldCode:
		return m.OldCode(ctx)
	case course.FieldSemesters:
		return m.OldSemesters(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case course.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case course.FieldSemesters:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemesters(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addsemesters != nil {
		fields = append(fields, course.FieldSemesters)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldSemesters:
		return m.AddedSemesters()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldSemesters:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSemesters(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldName:
		m.ResetName()
		return nil
	case course.FieldCode:
		m.ResetCode()
		return nil
	case course.FieldSemesters:
		m.ResetSemesters()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, course.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, course.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// AddUserIDs adds the users edge to User by ids.
func (m *DepartmentMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *DepartmentMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *DepartmentMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *DepartmentMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *DepartmentMutation) ResetUsers() {
	m.users = nil
	m.removedusers = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, department.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, department.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	email             *string
	hash              *string
	role              *user.Role
	photo             *string
	altEmail          *string
	phone             *string
	salutation        *string
	linkedin          *string
	twitter           *string
	facebook          *string
	github            *string
	rollNo            *string
	admissionTime     *time.Time
	courseEndTime     *time.Time
	_Designation      *string
	clearedFields     map[string]struct{}
	course            *int
	clearedcourse     bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetHash sets the hash field.
func (m *UserMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the hash value in the mutation.
func (m *UserMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old hash value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash reset all changes of the "hash" field.
func (m *UserMutation) ResetHash() {
	m.hash = nil
}

// SetRole sets the role field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the role value in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old role value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole reset all changes of the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetPhoto sets the photo field.
func (m *UserMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the photo value in the mutation.
func (m *UserMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old photo value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoto is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of photo.
func (m *UserMutation) ClearPhoto() {
	m.photo = nil
	m.clearedFields[user.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the field photo was cleared in this mutation.
func (m *UserMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoto]
	return ok
}

// ResetPhoto reset all changes of the "photo" field.
func (m *UserMutation) ResetPhoto() {
	m.photo = nil
	delete(m.clearedFields, user.FieldPhoto)
}

// SetAltEmail sets the altEmail field.
func (m *UserMutation) SetAltEmail(s string) {
	m.altEmail = &s
}

// AltEmail returns the altEmail value in the mutation.
func (m *UserMutation) AltEmail() (r string, exists bool) {
	v := m.altEmail
	if v == nil {
		return
	}
	return *v, true
}

// OldAltEmail returns the old altEmail value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAltEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAltEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAltEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltEmail: %w", err)
	}
	return oldValue.AltEmail, nil
}

// ClearAltEmail clears the value of altEmail.
func (m *UserMutation) ClearAltEmail() {
	m.altEmail = nil
	m.clearedFields[user.FieldAltEmail] = struct{}{}
}

// AltEmailCleared returns if the field altEmail was cleared in this mutation.
func (m *UserMutation) AltEmailCleared() bool {
	_, ok := m.clearedFields[user.FieldAltEmail]
	return ok
}

// ResetAltEmail reset all changes of the "altEmail" field.
func (m *UserMutation) ResetAltEmail() {
	m.altEmail = nil
	delete(m.clearedFields, user.FieldAltEmail)
}

// SetPhone sets the phone field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of phone.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the field phone was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone reset all changes of the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetSalutation sets the salutation field.
func (m *UserMutation) SetSalutation(s string) {
	m.salutation = &s
}

// Salutation returns the salutation value in the mutation.
func (m *UserMutation) Salutation() (r string, exists bool) {
	v := m.salutation
	if v == nil {
		return
	}
	return *v, true
}

// OldSalutation returns the old salutation value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldSalutation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalutation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalutation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalutation: %w", err)
	}
	return oldValue.Salutation, nil
}

// ClearSalutation clears the value of salutation.
func (m *UserMutation) ClearSalutation() {
	m.salutation = nil
	m.clearedFields[user.FieldSalutation] = struct{}{}
}

// SalutationCleared returns if the field salutation was cleared in this mutation.
func (m *UserMutation) SalutationCleared() bool {
	_, ok := m.clearedFields[user.FieldSalutation]
	return ok
}

// ResetSalutation reset all changes of the "salutation" field.
func (m *UserMutation) ResetSalutation() {
	m.salutation = nil
	delete(m.clearedFields, user.FieldSalutation)
}

// SetLinkedin sets the linkedin field.
func (m *UserMutation) SetLinkedin(s string) {
	m.linkedin = &s
}

// Linkedin returns the linkedin value in the mutation.
func (m *UserMutation) Linkedin() (r string, exists bool) {
	v := m.linkedin
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedin returns the old linkedin value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldLinkedin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkedin is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkedin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedin: %w", err)
	}
	return oldValue.Linkedin, nil
}

// ClearLinkedin clears the value of linkedin.
func (m *UserMutation) ClearLinkedin() {
	m.linkedin = nil
	m.clearedFields[user.FieldLinkedin] = struct{}{}
}

// LinkedinCleared returns if the field linkedin was cleared in this mutation.
func (m *UserMutation) LinkedinCleared() bool {
	_, ok := m.clearedFields[user.FieldLinkedin]
	return ok
}

// ResetLinkedin reset all changes of the "linkedin" field.
func (m *UserMutation) ResetLinkedin() {
	m.linkedin = nil
	delete(m.clearedFields, user.FieldLinkedin)
}

// SetTwitter sets the twitter field.
func (m *UserMutation) SetTwitter(s string) {
	m.twitter = &s
}

// Twitter returns the twitter value in the mutation.
func (m *UserMutation) Twitter() (r string, exists bool) {
	v := m.twitter
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitter returns the old twitter value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTwitter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTwitter is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTwitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitter: %w", err)
	}
	return oldValue.Twitter, nil
}

// ClearTwitter clears the value of twitter.
func (m *UserMutation) ClearTwitter() {
	m.twitter = nil
	m.clearedFields[user.FieldTwitter] = struct{}{}
}

// TwitterCleared returns if the field twitter was cleared in this mutation.
func (m *UserMutation) TwitterCleared() bool {
	_, ok := m.clearedFields[user.FieldTwitter]
	return ok
}

// ResetTwitter reset all changes of the "twitter" field.
func (m *UserMutation) ResetTwitter() {
	m.twitter = nil
	delete(m.clearedFields, user.FieldTwitter)
}

// SetFacebook sets the facebook field.
func (m *UserMutation) SetFacebook(s string) {
	m.facebook = &s
}

// Facebook returns the facebook value in the mutation.
func (m *UserMutation) Facebook() (r string, exists bool) {
	v := m.facebook
	if v == nil {
		return
	}
	return *v, true
}

// OldFacebook returns the old facebook value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFacebook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacebook is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacebook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacebook: %w", err)
	}
	return oldValue.Facebook, nil
}

// ClearFacebook clears the value of facebook.
func (m *UserMutation) ClearFacebook() {
	m.facebook = nil
	m.clearedFields[user.FieldFacebook] = struct{}{}
}

// FacebookCleared returns if the field facebook was cleared in this mutation.
func (m *UserMutation) FacebookCleared() bool {
	_, ok := m.clearedFields[user.FieldFacebook]
	return ok
}

// ResetFacebook reset all changes of the "facebook" field.
func (m *UserMutation) ResetFacebook() {
	m.facebook = nil
	delete(m.clearedFields, user.FieldFacebook)
}

// SetGithub sets the github field.
func (m *UserMutation) SetGithub(s string) {
	m.github = &s
}

// Github returns the github value in the mutation.
func (m *UserMutation) Github() (r string, exists bool) {
	v := m.github
	if v == nil {
		return
	}
	return *v, true
}

// OldGithub returns the old github value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldGithub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGithub is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithub: %w", err)
	}
	return oldValue.Github, nil
}

// ClearGithub clears the value of github.
func (m *UserMutation) ClearGithub() {
	m.github = nil
	m.clearedFields[user.FieldGithub] = struct{}{}
}

// GithubCleared returns if the field github was cleared in this mutation.
func (m *UserMutation) GithubCleared() bool {
	_, ok := m.clearedFields[user.FieldGithub]
	return ok
}

// ResetGithub reset all changes of the "github" field.
func (m *UserMutation) ResetGithub() {
	m.github = nil
	delete(m.clearedFields, user.FieldGithub)
}

// SetRollNo sets the rollNo field.
func (m *UserMutation) SetRollNo(s string) {
	m.rollNo = &s
}

// RollNo returns the rollNo value in the mutation.
func (m *UserMutation) RollNo() (r string, exists bool) {
	v := m.rollNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRollNo returns the old rollNo value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRollNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRollNo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRollNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRollNo: %w", err)
	}
	return oldValue.RollNo, nil
}

// ClearRollNo clears the value of rollNo.
func (m *UserMutation) ClearRollNo() {
	m.rollNo = nil
	m.clearedFields[user.FieldRollNo] = struct{}{}
}

// RollNoCleared returns if the field rollNo was cleared in this mutation.
func (m *UserMutation) RollNoCleared() bool {
	_, ok := m.clearedFields[user.FieldRollNo]
	return ok
}

// ResetRollNo reset all changes of the "rollNo" field.
func (m *UserMutation) ResetRollNo() {
	m.rollNo = nil
	delete(m.clearedFields, user.FieldRollNo)
}

// SetAdmissionTime sets the admissionTime field.
func (m *UserMutation) SetAdmissionTime(t time.Time) {
	m.admissionTime = &t
}

// AdmissionTime returns the admissionTime value in the mutation.
func (m *UserMutation) AdmissionTime() (r time.Time, exists bool) {
	v := m.admissionTime
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmissionTime returns the old admissionTime value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAdmissionTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdmissionTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdmissionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmissionTime: %w", err)
	}
	return oldValue.AdmissionTime, nil
}

// ClearAdmissionTime clears the value of admissionTime.
func (m *UserMutation) ClearAdmissionTime() {
	m.admissionTime = nil
	m.clearedFields[user.FieldAdmissionTime] = struct{}{}
}

// AdmissionTimeCleared returns if the field admissionTime was cleared in this mutation.
func (m *UserMutation) AdmissionTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldAdmissionTime]
	return ok
}

// ResetAdmissionTime reset all changes of the "admissionTime" field.
func (m *UserMutation) ResetAdmissionTime() {
	m.admissionTime = nil
	delete(m.clearedFields, user.FieldAdmissionTime)
}

// SetCourseEndTime sets the courseEndTime field.
func (m *UserMutation) SetCourseEndTime(t time.Time) {
	m.courseEndTime = &t
}

// CourseEndTime returns the courseEndTime value in the mutation.
func (m *UserMutation) CourseEndTime() (r time.Time, exists bool) {
	v := m.courseEndTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseEndTime returns the old courseEndTime value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCourseEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCourseEndTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCourseEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseEndTime: %w", err)
	}
	return oldValue.CourseEndTime, nil
}

// ClearCourseEndTime clears the value of courseEndTime.
func (m *UserMutation) ClearCourseEndTime() {
	m.courseEndTime = nil
	m.clearedFields[user.FieldCourseEndTime] = struct{}{}
}

// CourseEndTimeCleared returns if the field courseEndTime was cleared in this mutation.
func (m *UserMutation) CourseEndTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldCourseEndTime]
	return ok
}

// ResetCourseEndTime reset all changes of the "courseEndTime" field.
func (m *UserMutation) ResetCourseEndTime() {
	m.courseEndTime = nil
	delete(m.clearedFields, user.FieldCourseEndTime)
}

// SetDesignation sets the Designation field.
func (m *UserMutation) SetDesignation(s string) {
	m._Designation = &s
}

// Designation returns the Designation value in the mutation.
func (m *UserMutation) Designation() (r string, exists bool) {
	v := m._Designation
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignation returns the old Designation value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDesignation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesignation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesignation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignation: %w", err)
	}
	return oldValue.Designation, nil
}

// ClearDesignation clears the value of Designation.
func (m *UserMutation) ClearDesignation() {
	m._Designation = nil
	m.clearedFields[user.FieldDesignation] = struct{}{}
}

// DesignationCleared returns if the field Designation was cleared in this mutation.
func (m *UserMutation) DesignationCleared() bool {
	_, ok := m.clearedFields[user.FieldDesignation]
	return ok
}

// ResetDesignation reset all changes of the "Designation" field.
func (m *UserMutation) ResetDesignation() {
	m._Designation = nil
	delete(m.clearedFields, user.FieldDesignation)
}

// SetCourseID sets the course edge to Course by id.
func (m *UserMutation) SetCourseID(id int) {
	m.course = &id
}

// ClearCourse clears the course edge to Course.
func (m *UserMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared returns if the edge course was cleared.
func (m *UserMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the course id in the mutation.
func (m *UserMutation) CourseID() (id int, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the course ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse reset all changes of the "course" edge.
func (m *UserMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *UserMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *UserMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *UserMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *UserMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.hash != nil {
		fields = append(fields, user.FieldHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.photo != nil {
		fields = append(fields, user.FieldPhoto)
	}
	if m.altEmail != nil {
		fields = append(fields, user.FieldAltEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.salutation != nil {
		fields = append(fields, user.FieldSalutation)
	}
	if m.linkedin != nil {
		fields = append(fields, user.FieldLinkedin)
	}
	if m.twitter != nil {
		fields = append(fields, user.FieldTwitter)
	}
	if m.facebook != nil {
		fields = append(fields, user.FieldFacebook)
	}
	if m.github != nil {
		fields = append(fields, user.FieldGithub)
	}
	if m.rollNo != nil {
		fields = append(fields, user.FieldRollNo)
	}
	if m.admissionTime != nil {
		fields = append(fields, user.FieldAdmissionTime)
	}
	if m.courseEndTime != nil {
		fields = append(fields, user.FieldCourseEndTime)
	}
	if m._Designation != nil {
		fields = append(fields, user.FieldDesignation)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldHash:
		return m.Hash()
	case user.FieldRole:
		return m.Role()
	case user.FieldPhoto:
		return m.Photo()
	case user.FieldAltEmail:
		return m.AltEmail()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldSalutation:
		return m.Salutation()
	case user.FieldLinkedin:
		return m.Linkedin()
	case user.FieldTwitter:
		return m.Twitter()
	case user.FieldFacebook:
		return m.Facebook()
	case user.FieldGithub:
		return m.Github()
	case user.FieldRollNo:
		return m.RollNo()
	case user.FieldAdmissionTime:
		return m.AdmissionTime()
	case user.FieldCourseEndTime:
		return m.CourseEndTime()
	case user.FieldDesignation:
		return m.Designation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldHash:
		return m.OldHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldPhoto:
		return m.OldPhoto(ctx)
	case user.FieldAltEmail:
		return m.OldAltEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldSalutation:
		return m.OldSalutation(ctx)
	case user.FieldLinkedin:
		return m.OldLinkedin(ctx)
	case user.FieldTwitter:
		return m.OldTwitter(ctx)
	case user.FieldFacebook:
		return m.OldFacebook(ctx)
	case user.FieldGithub:
		return m.OldGithub(ctx)
	case user.FieldRollNo:
		return m.OldRollNo(ctx)
	case user.FieldAdmissionTime:
		return m.OldAdmissionTime(ctx)
	case user.FieldCourseEndTime:
		return m.OldCourseEndTime(ctx)
	case user.FieldDesignation:
		return m.OldDesignation(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case user.FieldAltEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldSalutation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalutation(v)
		return nil
	case user.FieldLinkedin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedin(v)
		return nil
	case user.FieldTwitter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitter(v)
		return nil
	case user.FieldFacebook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacebook(v)
		return nil
	case user.FieldGithub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithub(v)
		return nil
	case user.FieldRollNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRollNo(v)
		return nil
	case user.FieldAdmissionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmissionTime(v)
		return nil
	case user.FieldCourseEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseEndTime(v)
		return nil
	case user.FieldDesignation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignation(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhoto) {
		fields = append(fields, user.FieldPhoto)
	}
	if m.FieldCleared(user.FieldAltEmail) {
		fields = append(fields, user.FieldAltEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldSalutation) {
		fields = append(fields, user.FieldSalutation)
	}
	if m.FieldCleared(user.FieldLinkedin) {
		fields = append(fields, user.FieldLinkedin)
	}
	if m.FieldCleared(user.FieldTwitter) {
		fields = append(fields, user.FieldTwitter)
	}
	if m.FieldCleared(user.FieldFacebook) {
		fields = append(fields, user.FieldFacebook)
	}
	if m.FieldCleared(user.FieldGithub) {
		fields = append(fields, user.FieldGithub)
	}
	if m.FieldCleared(user.FieldRollNo) {
		fields = append(fields, user.FieldRollNo)
	}
	if m.FieldCleared(user.FieldAdmissionTime) {
		fields = append(fields, user.FieldAdmissionTime)
	}
	if m.FieldCleared(user.FieldCourseEndTime) {
		fields = append(fields, user.FieldCourseEndTime)
	}
	if m.FieldCleared(user.FieldDesignation) {
		fields = append(fields, user.FieldDesignation)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhoto:
		m.ClearPhoto()
		return nil
	case user.FieldAltEmail:
		m.ClearAltEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldSalutation:
		m.ClearSalutation()
		return nil
	case user.FieldLinkedin:
		m.ClearLinkedin()
		return nil
	case user.FieldTwitter:
		m.ClearTwitter()
		return nil
	case user.FieldFacebook:
		m.ClearFacebook()
		return nil
	case user.FieldGithub:
		m.ClearGithub()
		return nil
	case user.FieldRollNo:
		m.ClearRollNo()
		return nil
	case user.FieldAdmissionTime:
		m.ClearAdmissionTime()
		return nil
	case user.FieldCourseEndTime:
		m.ClearCourseEndTime()
		return nil
	case user.FieldDesignation:
		m.ClearDesignation()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldHash:
		m.ResetHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldPhoto:
		m.ResetPhoto()
		return nil
	case user.FieldAltEmail:
		m.ResetAltEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldSalutation:
		m.ResetSalutation()
		return nil
	case user.FieldLinkedin:
		m.ResetLinkedin()
		return nil
	case user.FieldTwitter:
		m.ResetTwitter()
		return nil
	case user.FieldFacebook:
		m.ResetFacebook()
		return nil
	case user.FieldGithub:
		m.ResetGithub()
		return nil
	case user.FieldRollNo:
		m.ResetRollNo()
		return nil
	case user.FieldAdmissionTime:
		m.ResetAdmissionTime()
		return nil
	case user.FieldCourseEndTime:
		m.ResetCourseEndTime()
		return nil
	case user.FieldDesignation:
		m.ResetDesignation()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.course != nil {
		edges = append(edges, user.EdgeCourse)
	}
	if m.department != nil {
		edges = append(edges, user.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcourse {
		edges = append(edges, user.EdgeCourse)
	}
	if m.cleareddepartment {
		edges = append(edges, user.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCourse:
		return m.clearedcourse
	case user.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCourse:
		m.ClearCourse()
		return nil
	case user.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCourse:
		m.ResetCourse()
		return nil
	case user.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
